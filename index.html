<!DOCTYPE html>
<html>
  <head>
    <title>Forbes 30 under 30</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tomorrow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    <style>
      html, body, main, main canvas {
          height: 100%;
          width: 100%;
          padding: 0;
          margin: 0;
      }

      #hint-text {
        position: fixed;
        top: 16px;
        left: 16px;
        z-index: 2000;
        color: white;
        font-family: "Tomorrow", sans-serif;
        font-size: 20px;
        pointer-events: auto;
      }

      #search-container {
        position: fixed;
        top: 16px;
        right: 16px;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        font-family: "Tomorrow", sans-serif;
      }

      #search-bar {
        display: flex;
        background: rgba(40, 44, 52, 0.92);
        border: 1px solid white;
        border-radius: 0;
        overflow: hidden;
      }

      #search-input {
        width: 180px;
        padding: 10px 14px;
        border: none;
        outline: none;
        background: rgb(70, 76, 94);
        color: white;
        font-size: 14px;
        font-family: "Tomorrow", sans-serif;
      }

      #search-input::placeholder {
        color: rgba(255,255,255,0.5);
      }

      #search-btn {
        padding: 10px 16px;
        border: none;
        border-left: 1px solid rgba(0, 200, 255, 0.3);
        background: white;
        color: rgb(70, 76, 94);
        font-size: 14px;
        cursor: pointer;
        font-family: "Tomorrow", sans-serif;
        transition: background 0.2s, color 0.2s;
      }

      #search-btn:hover {
        background: rgba(255, 255, 255, 0.85);
        color: rgb(70, 76, 94);
      }

      #search-results {
        display: none;
        margin-top: 4px;
        background: rgba(40, 44, 52, 0.95);
        border: 1px solid rgba(0, 200, 255, 0.6);
        border-radius: 8px;
        max-height: 240px;
        overflow-y: auto;
        width: 100%;
      }

      .search-result-item {
        padding: 10px 14px;
        color: white;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.15s;
      }

      .search-result-item:first-child {
        border-radius: 8px 8px 0 0;
      }

      .search-result-item:last-child {
        border-radius: 0 0 8px 8px;
      }

      .search-result-item:only-child {
        border-radius: 8px;
      }

      .search-result-item:hover {
        background: rgba(255,255,255,0.15);
      }

      #search-no-results {
        padding: 10px 14px;
        color: rgba(255,255,255,0.5);
        font-size: 14px;
      }

      .search-result-year {
        color: rgba(255,255,255,0.45);
        font-size: 12px;
        margin-left: 6px;
      }

      @media (max-width: 1000px) {
        #hint-text {
          font-size: 40px;
        }
        #hint-text span {
          font-size: 28px !important;
        }
        #hint-text button {
          font-size: 28px !important;
        }
        #search-input {
          font-size: 28px;
          width: 300px;
        }
        #search-btn {
          font-size: 28px;
        }
        .search-result-item {
          font-size: 28px;
        }
        .search-result-year {
          font-size: 22px;
        }
        #search-no-results {
          font-size: 28px;
        }
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
      let headModel, eyesModel, smileModel, frownModel;
      let boxConfigs = [];
      let peopleData = [];
      let clickPending = false;
      let clickX, clickY;
      let pressX, pressY;
      let tooltipDiv;
      let camDist, camRotX, camRotY;
      let selectedBox = null;
      let dataLoaded = false;

      // Momentum state for drag inertia
      let velRotX = 0, velRotY = 0;
      let isDragging = false;
      const dragSensitivity = 0.3;
      let currentFriction = 0.425;
      const frictionMin = 0.375;
      const frictionMax = 0.75;
      const minVelocity = 0.01;

      // Animation state for search-based navigation
      let isAnimating = false;
      let animStartRotX, animStartRotY;
      let animTargetRotX, animTargetRotY;
      let animStartDist, animTargetDist;
      let animProgress = 0;
      let animTargetBox = null;

      function buildTooltipHtml(person) {
        let html = '<div style="max-width:400px;max-height:600px;overflow-y:auto;">';
        html += '<div style="font-size:16px;font-weight:bold;margin-bottom:6px;">' + escapeHtml(person.name) + '</div>';
        html += '<div style="margin-bottom:4px;"><b>Year:</b> ' + escapeHtml(person.year) + '</div>';
        html += '<div style="margin-bottom:4px;"><b>Age:</b> ' + escapeHtml(person.age) + '</div>';
        html += '<div style="margin-bottom:4px;"><b>Title:</b> ' + escapeHtml(person.title) + '</div>';
        html += '<div style="margin-bottom:4px;"><b>Company:</b> ' + escapeHtml(person.company) + '</div>';
        html += '<div style="margin-bottom:4px;"><b>Category:</b> ' + escapeHtml(person.category) + '</div>';
        if (person.description) {
          html += '<div style="margin-bottom:4px;"><b>Description:</b> ' + escapeHtml(person.description) + '</div>';
        }
        let fraudVal = person.fraud || 'N/A';
        let color = fraudVal === 'N/A' ? '#50cd32' : '#ff6b6b';
        html += '<div style="margin-top:6px;padding-top:6px;border-top:1px solid rgba(255,255,255,0.2);color:' + color + ';"><b>Fraud:</b> ' + marked.parse(fraudVal) + '</div>';
        html += '</div>';
        return html;
      }

      function escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
      }

      function setup() {
        createCanvas(windowWidth, windowHeight, WEBGL);
	angleMode(DEGREES);
	strokeWeight(2);
	noFill();
	stroke(32, 8, 64);
	describe(
	  'Users can click on the screen and drag to adjust their perspective in 3D space. The space contains a sphere of dark purple astronaut figures on a light pink background.'
	);

	// Head (shared by both)
	headModel = buildGeometry(function() {
	  sphere(3, 8, 6);
	});

	// Eyes (shared by both)
	eyesModel = buildGeometry(function() {
	  push(); translate(-1, -0.8, 2.5); sphere(0.5, 5, 4); pop();
	  push(); translate(1, -0.8, 2.5); sphere(0.5, 5, 4); pop();
	});

	// Smile arc
	smileModel = buildGeometry(function() {
	  for (let i = -3; i <= 3; i++) {
	    push();
	    translate(i * 0.5, 1.2 - i * i * 0.044, 2.6);
	    sphere(0.25, 4, 4);
	    pop();
	  }
	});

	// Frown arc
	frownModel = buildGeometry(function() {
	  for (let i = -3; i <= 3; i++) {
	    push();
	    translate(i * 0.5, 0.8 + i * i * 0.044, 2.6);
	    sphere(0.25, 4, 4);
	    pop();
	  }
	});

	// Initialize orbit camera to match original camera(800, -600, 4000)
	camDist = sqrt(800*800 + 600*600 + 4000*4000);
	camRotX = asin(600 / camDist);
	camRotY = atan2(800, 4000);

	// Create tooltip element
	tooltipDiv = createDiv('');
	tooltipDiv.style('position', 'fixed');
	tooltipDiv.style('bottom', '8px');
	tooltipDiv.style('right', '8px');
	tooltipDiv.style('background', 'rgba(32, 8, 64, 0.9)');
	tooltipDiv.style('color', 'white');
	tooltipDiv.style('padding', '8px 12px');
	tooltipDiv.style('border-radius', '6px 0 0 0');
	tooltipDiv.style('font-family', '"Tomorrow", sans-serif');
	tooltipDiv.style('font-size', '14px');
	tooltipDiv.style('pointer-events', 'none');
	tooltipDiv.style('display', 'none');
	tooltipDiv.style('z-index', '1000');
	tooltipDiv.style('max-height', '600px');

	// Fetch JSON data and build sphere
	fetch("/file.json")
	  .then(function(r) { return r.json(); })
	  .then(function(data) {
	    peopleData = data;
	    buildSphere(data.length);
	    dataLoaded = true;
	  });
      }

      function buildSphere(maxBoxes) {
	let numBoxes = 0;
	for (let offset = 0; offset <= 90 && numBoxes < maxBoxes; offset += 2) {
	  let angles = [90 - offset];
	  if (offset > 0) angles.push(90 + offset);
	  for (let zAngle of angles) {
	    if (zAngle < 0 || zAngle >= 180) continue;
	    let ringRadius = sin(zAngle);
	    let step = ringRadius > 0.05 ? 3 / ringRadius : 60;
	    for (let xAngle = 0; xAngle < 360 && numBoxes < maxBoxes; xAngle += step) {
	      let r = 2000;
	      let y1 = r * cos(xAngle);
	      let z1 = r * sin(xAngle);
	      let wx = -y1 * sin(zAngle);
	      let wy = y1 * cos(zAngle);
	      let wz = z1;
	      let person = peopleData[numBoxes];
	      let fraudVal = (person.fraud || '').trim();
	      let isClean = (fraudVal === 'N/A' || fraudVal === '');
	      boxConfigs.push({ zAngle, xAngle, boxNumber: numBoxes + 1, wx, wy, wz, isClean, idx: numBoxes });
	      numBoxes++;
	    }
	  }
	}
      }

      // Raycast from camera through click point, find closest box
      function handleBoxClick(eyeX, eyeY, eyeZ) {
	let fLen = sqrt(eyeX*eyeX + eyeY*eyeY + eyeZ*eyeZ);
	let fx = -eyeX/fLen, fy = -eyeY/fLen, fz = -eyeZ/fLen;

	let rx = -fz, ry = 0, rz = fx;
	let rLen = sqrt(rx*rx + rz*rz);
	rx /= rLen; rz /= rLen;

	let ux = ry*fz - rz*fy, uy = rz*fx - rx*fz, uz = rx*fy - ry*fx;
	let uLen = sqrt(ux*ux + uy*uy + uz*uz);
	ux /= uLen; uy /= uLen; uz /= uLen;

	let halfTan = tan(30);
	let aspect = width / height;

	let ndcX = (clickX - width / 2) / (width / 2);
	let ndcY = (clickY - height / 2) / (height / 2);

	let dx = fx + rx * ndcX * halfTan * aspect + ux * ndcY * halfTan;
	let dy = fy + uy * ndcY * halfTan;
	let dz = fz + rz * ndcX * halfTan * aspect + uz * ndcY * halfTan;
	let dLen = sqrt(dx*dx + dy*dy + dz*dz);
	dx /= dLen; dy /= dLen; dz /= dLen;

	let closestBox = null;
	let closestDistSq = Infinity;

	for (let i = 0; i < boxConfigs.length; i++) {
	  let cfg = boxConfigs[i];
	  if (cfg.wx * (eyeX - cfg.wx) + cfg.wy * (eyeY - cfg.wy) + cfg.wz * (eyeZ - cfg.wz) <= 0) continue;
	  let tx = cfg.wx - eyeX;
	  let ty = cfg.wy - eyeY;
	  let tz = cfg.wz - eyeZ;
	  let t = tx*dx + ty*dy + tz*dz;
	  if (t < 0) continue;
	  let cx = eyeX + dx*t - cfg.wx;
	  let cy = eyeY + dy*t - cfg.wy;
	  let cz = eyeZ + dz*t - cfg.wz;
	  let dSq = cx*cx + cy*cy + cz*cz;
	  if (dSq < closestDistSq) {
	    closestDistSq = dSq;
	    closestBox = cfg;
	  }
	}

	if (closestBox && closestDistSq < 40*40) {
	  selectedBox = closestBox.boxNumber;
	  let person = peopleData[closestBox.idx];
	  tooltipDiv.html(buildTooltipHtml(person));
	  tooltipDiv.style('display', 'block');
	  tooltipDiv.style('pointer-events', 'auto');
	} else {
	  selectedBox = null;
	  tooltipDiv.style('display', 'none');
	  tooltipDiv.style('pointer-events', 'none');
	}
      }

      function draw() {
	background(70,76,94);

	if (!dataLoaded) {
	  push();
	  fill(255);
	  noStroke();
	  textAlign(CENTER, CENTER);
	  textSize(20);
	  text('Loading...', 0, 0);
	  pop();
	  return;
	}

	// Handle animation from search selection
	if (isAnimating) {
	  animProgress += 0.018;
	  if (animProgress >= 1) {
	    animProgress = 1;
	    isAnimating = false;
	    camRotX = animTargetRotX;
	    camRotY = animTargetRotY;
	    camDist = animTargetDist;
	    if (animTargetBox) {
	      selectedBox = animTargetBox.boxNumber;
	      let person = peopleData[animTargetBox.idx];
	      tooltipDiv.html(buildTooltipHtml(person));
	      tooltipDiv.style('display', 'block');
	      tooltipDiv.style('pointer-events', 'auto');
	    }
	  } else {
	    let t = easeInOutCubic(animProgress);
	    camRotX = animStartRotX + (animTargetRotX - animStartRotX) * t;
	    camRotY = animStartRotY + (animTargetRotY - animStartRotY) * t;
	    camDist = animStartDist + (animTargetDist - animStartDist) * t;
	  }
	} else if (mouseIsPressed) {
	  isDragging = true;
	  let mx = (mouseX - pmouseX) || 0;
	  let my = (mouseY - pmouseY) || 0;
	  velRotY = -mx * dragSensitivity;
	  velRotX = my * dragSensitivity;
	  camRotY += velRotY;
	  camRotX += velRotX;
	  camRotX = constrain(camRotX, -89, 89);
	  if ((mx !== 0 || my !== 0) && selectedBox !== null) {
	    selectedBox = null;
	    tooltipDiv.style('display', 'none');
	    tooltipDiv.style('pointer-events', 'none');
	  }
	} else if (isDragging || (abs(velRotX) > minVelocity || abs(velRotY) > minVelocity)) {
	  isDragging = false;
	  velRotX *= currentFriction;
	  velRotY *= currentFriction;
	  if (abs(velRotX) < minVelocity) velRotX = 0;
	  if (abs(velRotY) < minVelocity) velRotY = 0;
	  camRotY += velRotY;
	  camRotX += velRotX;
	  camRotX = constrain(camRotX, -89, 89);
	}

	let eyeX = camDist * sin(camRotY) * cos(camRotX);
	let eyeY = -camDist * sin(camRotX);
	let eyeZ = camDist * cos(camRotY) * cos(camRotX);
	camera(eyeX, eyeY, eyeZ, 0, 0, 0, 0, 1, 0);

	if (clickPending) {
	  clickPending = false;
	  handleBoxClick(eyeX, eyeY, eyeZ);
	}

	// Draw all faces
	for (let i = 0; i < boxConfigs.length; i++) {
	  let cfg = boxConfigs[i];
	  if (cfg.wx * (eyeX - cfg.wx) + cfg.wy * (eyeY - cfg.wy) + cfg.wz * (eyeZ - cfg.wz) <= 0) continue;
	  push();
	  rotateZ(cfg.zAngle);
	  rotateX(cfg.xAngle);
	  translate(0, 2000, 0);
	  rotateX(-90);
	  let isSel = cfg.boxNumber === selectedBox;
	  // Head color: blue=selected, green=clean(N/A), orange=fraud
	  if (isSel) { fill(0, 100, 255); stroke(0, 80, 200); }
	  else if (cfg.isClean) { fill(50, 205, 50); stroke(30, 170, 30); }
	  else { fill(255, 165, 0); stroke(220, 130, 0); }
	  model(headModel);
	  // Eyes
	  fill(20, 20, 20); stroke(0);
	  model(eyesModel);
	  // Mouth: smile for clean, frown for fraud
	  if (isSel) { fill(255, 255, 255); stroke(200); }
	  else { fill(200, 30, 30); stroke(150, 20, 20); }
	  model(cfg.isClean ? smileModel : frownModel);
	  pop();
	}
      }

      function mousePressed() {
	if (isAnimating) {
	  isAnimating = false;
	}
	velRotX = 0;
	velRotY = 0;
	isDragging = false;
	pressX = mouseX;
	pressY = mouseY;
      }

      function mouseReleased() {
	let dragDist = dist(pressX, pressY, mouseX, mouseY);
	let t = constrain(map(dragDist, 20, 300, 0, 1), 0, 1);
	currentFriction = lerp(frictionMin, frictionMax, t);
	if (dragDist < 5) {
	  clickPending = true;
	  clickX = mouseX;
	  clickY = mouseY;
	}
      }

      function touchMoved() {
	return false;
      }

      function mouseWheel(event) {
	if (selectedBox !== null) return;
	camDist += event.delta * 2;
	camDist = constrain(camDist, 500, 10000);
	return false;
      }

      function windowResized() {
	resizeCanvas(windowWidth, windowHeight);
      }

      // --- Search functionality ---

      function initSearch() {
	let input = document.getElementById('search-input');
	let btn = document.getElementById('search-btn');
	let resultsDiv = document.getElementById('search-results');

	input.addEventListener('input', function() {
	  performSearch(this.value.trim());
	});

	input.addEventListener('keydown', function(e) {
	  if (e.key === 'Enter') {
	    e.preventDefault();
	    let firstItem = resultsDiv.querySelector('.search-result-item');
	    if (firstItem) firstItem.click();
	  }
	  if (e.key === 'Escape') {
	    resultsDiv.style.display = 'none';
	    input.blur();
	  }
	});

	btn.addEventListener('click', function() {
	  let firstItem = resultsDiv.querySelector('.search-result-item');
	  if (firstItem) firstItem.click();
	  else performSearch(input.value.trim());
	});

	document.addEventListener('keydown', function(e) {
	  if (e.key === 'Escape') {
	    selectedBox = null;
	    tooltipDiv.style('display', 'none');
	    tooltipDiv.style('pointer-events', 'none');
	  }
	});

	document.addEventListener('mousedown', function(e) {
	  if (!e.target.closest('#search-container')) {
	    resultsDiv.style.display = 'none';
	  }
	});

	input.addEventListener('mousedown', function(e) { e.stopPropagation(); });
	input.addEventListener('mouseup', function(e) { e.stopPropagation(); });
      }

      function performSearch(query) {
	let resultsDiv = document.getElementById('search-results');
	resultsDiv.innerHTML = '';

	if (!query || !dataLoaded) {
	  resultsDiv.style.display = 'none';
	  return;
	}

	let lowerQuery = query.toLowerCase();

	// Find matching boxConfigs by person name
	let matches = [];
	for (let i = 0; i < boxConfigs.length; i++) {
	  let person = peopleData[boxConfigs[i].idx];
	  if (person.name && person.name.toLowerCase().indexOf(lowerQuery) !== -1) {
	    matches.push(boxConfigs[i]);
	  }
	}

	// Sort: exact match first, then startsWith, then contains
	matches.sort(function(a, b) {
	  let aName = peopleData[a.idx].name.toLowerCase();
	  let bName = peopleData[b.idx].name.toLowerCase();
	  let aExact = aName === lowerQuery;
	  let bExact = bName === lowerQuery;
	  if (aExact !== bExact) return aExact ? -1 : 1;
	  let aStarts = aName.indexOf(lowerQuery) === 0;
	  let bStarts = bName.indexOf(lowerQuery) === 0;
	  if (aStarts !== bStarts) return aStarts ? -1 : 1;
	  return aName.localeCompare(bName);
	});

	matches = matches.slice(0, 20);

	if (matches.length === 0) {
	  resultsDiv.innerHTML = '<div id="search-no-results">No results</div>';
	  resultsDiv.style.display = 'block';
	  return;
	}

	matches.forEach(function(cfg) {
	  let person = peopleData[cfg.idx];
	  let item = document.createElement('div');
	  item.className = 'search-result-item';
	  item.innerHTML = escapeHtml(person.name) + '<span class="search-result-year">' + escapeHtml(person.year) + '</span>';
	  item.addEventListener('click', function() {
	    selectSearchResult(cfg);
	    resultsDiv.style.display = 'none';
	    document.getElementById('search-input').value = person.name;
	  });
	  resultsDiv.appendChild(item);
	});
	resultsDiv.style.display = 'block';
      }

      function selectSearchResult(cfg) {
	let r = 2000;
	animTargetRotX = asin(constrain(-cfg.wy / r, -1, 1));
	animTargetRotX = constrain(animTargetRotX, -89, 89);
	animTargetRotY = atan2(cfg.wx, cfg.wz);

	animStartRotX = camRotX;
	animStartRotY = camRotY;
	animStartDist = camDist;
	animTargetDist = 2350;

	let diffY = animTargetRotY - animStartRotY;
	while (diffY > 180) diffY -= 360;
	while (diffY < -180) diffY += 360;
	animTargetRotY = animStartRotY + diffY;

	animProgress = 0;
	animTargetBox = cfg;
	isAnimating = true;

	selectedBox = null;
	tooltipDiv.style('display', 'none');
	tooltipDiv.style('pointer-events', 'none');
      }

      function easeInOutCubic(t) {
	return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      window.addEventListener('DOMContentLoaded', function() {
	initSearch();
      });
    </script>
  </head>
  <body>
    <div id="hint-text">Click and drag around!<br><span style="font-size: 14px; display: inline-block; margin-top: 6px;">Made by <a href="https://x.com/itisyev" target="_blank" style="color: white; text-decoration: underline;">Yev</a></span><br><button onclick="alert('This was made by scraping Forbes 30 under 30 winners and searching for known cases of fraud, lawsuits, or controversy.\n\nSome were done humorously and some were done with people who may have common names.\n\nIf there is a change you would like to request, feel free to DM me on X @itisyev')" style="margin-top: 6px; font-size: 14px; font-family: 'Tomorrow', sans-serif; background: none; border: 1px solid white; color: white; padding: 4px 12px; cursor: pointer;">Info</button></div>
    <div id="search-container">
      <div id="search-bar">
        <input id="search-input" type="text" placeholder="Search by name" autocomplete="off" />
        <button id="search-btn">Search</button>
      </div>
      <div id="search-results"></div>
    </div>
  </body>
</html>
