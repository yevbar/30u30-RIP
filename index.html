<!DOCTYPE html>
<html>
  <head>
    <title>Forbes 30 under 30</title>
    <style>
      html, body, main, main canvas {
          height: 100%;
          width: 100%;
          padding: 0;
          margin: 0;
      }

      #search-container {
        position: fixed;
        top: 16px;
        right: 16px;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        font-family: sans-serif;
      }

      #search-bar {
        display: flex;
        background: rgba(40, 44, 52, 0.92);
        border: 1px solid rgba(0, 200, 255, 0.6);
        border-radius: 8px;
        overflow: hidden;
      }

      #search-input {
        width: 180px;
        padding: 10px 14px;
        border: none;
        outline: none;
        background: transparent;
        color: white;
        font-size: 14px;
        font-family: sans-serif;
      }

      #search-input::placeholder {
        color: rgba(255,255,255,0.5);
      }

      #search-btn {
        padding: 10px 16px;
        border: none;
        border-left: 1px solid rgba(0, 200, 255, 0.3);
        background: rgba(0, 200, 255, 0.15);
        color: white;
        font-size: 14px;
        cursor: pointer;
        font-family: sans-serif;
        transition: background 0.2s, color 0.2s;
      }

      #search-btn:hover {
        background: rgba(0, 200, 255, 0.3);
        color: white;
      }

      #search-results {
        display: none;
        margin-top: 4px;
        background: rgba(40, 44, 52, 0.95);
        border: 1px solid rgba(0, 200, 255, 0.6);
        border-radius: 8px;
        max-height: 240px;
        overflow-y: auto;
        width: 100%;
      }

      .search-result-item {
        padding: 10px 14px;
        color: white;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.15s;
      }

      .search-result-item:first-child {
        border-radius: 8px 8px 0 0;
      }

      .search-result-item:last-child {
        border-radius: 0 0 8px 8px;
      }

      .search-result-item:only-child {
        border-radius: 8px;
      }

      .search-result-item:hover {
        background: rgba(255,255,255,0.15);
      }

      #search-no-results {
        padding: 10px 14px;
        color: rgba(255,255,255,0.5);
        font-size: 14px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.js"></script>
    <script>
      let headModel, eyesModel, smileModel, frownModel;
      let boxConfigs = [];
      let clickPending = false;
      let clickX, clickY;
      let pressX, pressY;
      let tooltipDiv;
      let camDist, camRotX, camRotY;
      let selectedBox = null;

      // Animation state for search-based navigation
      let isAnimating = false;
      let animStartRotX, animStartRotY;
      let animTargetRotX, animTargetRotY;
      let animProgress = 0;
      let animTargetBox = null;

      function setup() {
        createCanvas(windowWidth, windowHeight, WEBGL);
	angleMode(DEGREES);
	strokeWeight(2);
	noFill();
	stroke(32, 8, 64);
	describe(
	  'Users can click on the screen and drag to adjust their perspective in 3D space. The space contains a sphere of dark purple astronaut figures on a light pink background.'
	);

	// Head (shared by both)
	headModel = buildGeometry(function() {
	  sphere(3, 8, 6);
	});

	// Eyes (shared by both)
	eyesModel = buildGeometry(function() {
	  push(); translate(-1, -0.8, 2.5); sphere(0.5, 5, 4); pop();
	  push(); translate(1, -0.8, 2.5); sphere(0.5, 5, 4); pop();
	});

	// Smile arc
	smileModel = buildGeometry(function() {
	  for (let i = -3; i <= 3; i++) {
	    push();
	    translate(i * 0.5, 1.2 - i * i * 0.044, 2.6);
	    sphere(0.25, 4, 4);
	    pop();
	  }
	});

	// Frown arc
	frownModel = buildGeometry(function() {
	  for (let i = -3; i <= 3; i++) {
	    push();
	    translate(i * 0.5, 0.8 + i * i * 0.044, 2.6);
	    sphere(0.25, 4, 4);
	    pop();
	  }
	});

	// Initialize orbit camera to match original camera(800, -600, 4000)
	camDist = sqrt(800*800 + 600*600 + 4000*4000);
	camRotX = asin(600 / camDist);
	camRotY = atan2(800, 4000);

	// Pre-compute box configs with world positions
	let numBoxes = 0;
	const maxBoxes = 8215;
	for (let offset = 0; offset <= 90 && numBoxes < maxBoxes; offset += 2) {
	  let angles = [90 - offset];
	  if (offset > 0) angles.push(90 + offset);
	  for (let zAngle of angles) {
	    if (zAngle < 0 || zAngle >= 180) continue;
	    let ringRadius = sin(zAngle);
	    let step = ringRadius > 0.05 ? 3 / ringRadius : 60;
	    for (let xAngle = 0; xAngle < 360 && numBoxes < maxBoxes; xAngle += step) {
	      // Compute world position: rotateZ(zAngle) * rotateX(xAngle) * (0, 2000, 0)
	      let r = 2000;
	      let y1 = r * cos(xAngle);
	      let z1 = r * sin(xAngle);
	      let wx = -y1 * sin(zAngle);
	      let wy = y1 * cos(zAngle);
	      let wz = z1;
	      boxConfigs.push({ zAngle, xAngle, boxNumber: numBoxes + 1, wx, wy, wz, isOdd: (numBoxes + 1) % 2 === 1 });
	      numBoxes++;
	    }
	  }
	}

	// Create tooltip element
	tooltipDiv = createDiv('');
	tooltipDiv.style('position', 'absolute');
	tooltipDiv.style('background', 'rgba(32, 8, 64, 0.9)');
	tooltipDiv.style('color', 'white');
	tooltipDiv.style('padding', '8px 12px');
	tooltipDiv.style('border-radius', '6px');
	tooltipDiv.style('font-family', 'sans-serif');
	tooltipDiv.style('font-size', '14px');
	tooltipDiv.style('pointer-events', 'none');
	tooltipDiv.style('display', 'none');
	tooltipDiv.style('z-index', '1000');
      }

      // Raycast from camera through click point, find closest box
      function handleBoxClick(eyeX, eyeY, eyeZ) {
	// Build camera basis vectors
	let fLen = sqrt(eyeX*eyeX + eyeY*eyeY + eyeZ*eyeZ);
	let fx = -eyeX/fLen, fy = -eyeY/fLen, fz = -eyeZ/fLen; // forward (toward origin)

	// right = cross(forward, worldUp(0,1,0)) = (-fz, 0, fx)
	let rx = -fz, ry = 0, rz = fx;
	let rLen = sqrt(rx*rx + rz*rz);
	rx /= rLen; rz /= rLen;

	// up = cross(right, forward)
	let ux = ry*fz - rz*fy, uy = rz*fx - rx*fz, uz = rx*fy - ry*fx;
	let uLen = sqrt(ux*ux + uy*uy + uz*uz);
	ux /= uLen; uy /= uLen; uz /= uLen;

	// Default p5.js FOV is 60 degrees
	let halfTan = tan(30);
	let aspect = width / height;

	// Mouse position to NDC
	let ndcX = (clickX - width / 2) / (width / 2);
	let ndcY = (clickY - height / 2) / (height / 2);

	// Ray direction
	let dx = fx + rx * ndcX * halfTan * aspect + ux * ndcY * halfTan;
	let dy = fy + uy * ndcY * halfTan;
	let dz = fz + rz * ndcX * halfTan * aspect + uz * ndcY * halfTan;
	let dLen = sqrt(dx*dx + dy*dy + dz*dz);
	dx /= dLen; dy /= dLen; dz /= dLen;

	let closestBox = null;
	let closestDistSq = Infinity;

	for (let i = 0; i < boxConfigs.length; i++) {
	  let cfg = boxConfigs[i];
	  // Vector from eye to box
	  let tx = cfg.wx - eyeX;
	  let ty = cfg.wy - eyeY;
	  let tz = cfg.wz - eyeZ;
	  // Project onto ray
	  let t = tx*dx + ty*dy + tz*dz;
	  if (t < 0) continue; // behind camera
	  // Distance from box center to closest point on ray
	  let cx = eyeX + dx*t - cfg.wx;
	  let cy = eyeY + dy*t - cfg.wy;
	  let cz = eyeZ + dz*t - cfg.wz;
	  let dSq = cx*cx + cy*cy + cz*cz;
	  if (dSq < closestDistSq) {
	    closestDistSq = dSq;
	    closestBox = cfg;
	  }
	}

	if (closestBox && closestDistSq < 40*40) {
	  selectedBox = closestBox.boxNumber;
	  tooltipDiv.html('Box #' + closestBox.boxNumber);
	  tooltipDiv.style('display', 'block');
	  tooltipDiv.position(clickX + 15, clickY - 15);
	} else {
	  selectedBox = null;
	  tooltipDiv.style('display', 'none');
	}
      }

      function draw() {
	background(204, 205, 198);

	// Handle animation from search selection
	if (isAnimating) {
	  animProgress += 0.018;
	  if (animProgress >= 1) {
	    animProgress = 1;
	    isAnimating = false;
	    camRotX = animTargetRotX;
	    camRotY = animTargetRotY;
	    // Animation complete: select the box and show tooltip
	    if (animTargetBox) {
	      selectedBox = animTargetBox.boxNumber;
	      tooltipDiv.html('Box #' + animTargetBox.boxNumber);
	      tooltipDiv.style('display', 'block');
	      // Position tooltip at center of screen with offset
	      tooltipDiv.position(width / 2 + 20, height / 2 - 20);
	    }
	  } else {
	    let t = easeInOutCubic(animProgress);
	    camRotX = animStartRotX + (animTargetRotX - animStartRotX) * t;
	    camRotY = animStartRotY + (animTargetRotY - animStartRotY) * t;
	  }
	} else if (mouseIsPressed) {
	  // Manual orbit control: drag to rotate
	  camRotY -= movedX * 0.3;
	  camRotX += movedY * 0.3;
	  camRotX = constrain(camRotX, -89, 89);
	  if ((movedX !== 0 || movedY !== 0) && selectedBox !== null) {
	    selectedBox = null;
	    tooltipDiv.style('display', 'none');
	  }
	}

	// Compute camera position from orbit angles
	let eyeX = camDist * sin(camRotY) * cos(camRotX);
	let eyeY = -camDist * sin(camRotX);
	let eyeZ = camDist * cos(camRotY) * cos(camRotX);
	camera(eyeX, eyeY, eyeZ, 0, 0, 0, 0, 1, 0);

	// Handle click via raycasting
	if (clickPending) {
	  clickPending = false;
	  handleBoxClick(eyeX, eyeY, eyeZ);
	}

	// Draw all boxes with back-face culling
	for (let i = 0; i < boxConfigs.length; i++) {
	  let cfg = boxConfigs[i];
	  // Back-face culling: skip faces whose outward normal points away from camera
	  // Normal is (wx, wy, wz), view vector is (eyeX - wx, eyeY - wy, eyeZ - wz)
	  if (cfg.wx * (eyeX - cfg.wx) + cfg.wy * (eyeY - cfg.wy) + cfg.wz * (eyeZ - cfg.wz) <= 0) continue;
	  push();
	  rotateZ(cfg.zAngle);
	  rotateX(cfg.xAngle);
	  translate(0, 2000, 0);
	  rotateX(-90);
	  let isSel = cfg.boxNumber === selectedBox;
	  // Head
	  if (isSel) { fill(0, 100, 255); stroke(0, 80, 200); }
	  else if (cfg.isOdd) { fill(50, 205, 50); stroke(30, 170, 30); }
	  else { fill(255, 165, 0); stroke(220, 130, 0); }
	  model(headModel);
	  // Eyes
	  fill(20, 20, 20); stroke(0);
	  model(eyesModel);
	  // Mouth
	  if (isSel) { fill(255, 255, 255); stroke(200); }
	  else { fill(200, 30, 30); stroke(150, 20, 20); }
	  model(cfg.isOdd ? smileModel : frownModel);
	  pop();
	}
      }

      function mousePressed() {
	// Cancel animation if user starts interacting
	if (isAnimating) {
	  isAnimating = false;
	}
	pressX = mouseX;
	pressY = mouseY;
      }

      function mouseReleased() {
	// Only treat as a click if the mouse didn't move (not a drag for orbit)
	if (dist(pressX, pressY, mouseX, mouseY) < 5) {
	  clickPending = true;
	  clickX = mouseX;
	  clickY = mouseY;
	}
      }

      function mouseWheel(event) {
	camDist += event.delta * 2;
	camDist = constrain(camDist, 500, 10000);
	return false;
      }

      function windowResized() {
	// Resize the canvas to the new window dimensions
	resizeCanvas(windowWidth, windowHeight);
      }

      // --- Search functionality ---

      function initSearch() {
	let input = document.getElementById('search-input');
	let btn = document.getElementById('search-btn');
	let resultsDiv = document.getElementById('search-results');

	input.addEventListener('input', function() {
	  performSearch(this.value.trim());
	});

	input.addEventListener('keydown', function(e) {
	  if (e.key === 'Enter') {
	    e.preventDefault();
	    // Select the first result if available
	    let firstItem = resultsDiv.querySelector('.search-result-item');
	    if (firstItem) firstItem.click();
	  }
	  if (e.key === 'Escape') {
	    resultsDiv.style.display = 'none';
	    input.blur();
	  }
	});

	btn.addEventListener('click', function() {
	  let firstItem = resultsDiv.querySelector('.search-result-item');
	  if (firstItem) firstItem.click();
	  else performSearch(input.value.trim());
	});

	// Escape key clears highlighted box and tooltip
	document.addEventListener('keydown', function(e) {
	  if (e.key === 'Escape') {
	    selectedBox = null;
	    tooltipDiv.style('display', 'none');
	  }
	});

	// Close results when clicking outside
	document.addEventListener('mousedown', function(e) {
	  if (!e.target.closest('#search-container')) {
	    resultsDiv.style.display = 'none';
	  }
	});

	// Prevent canvas interaction when typing in search
	input.addEventListener('mousedown', function(e) { e.stopPropagation(); });
	input.addEventListener('mouseup', function(e) { e.stopPropagation(); });
      }

      function performSearch(query) {
	let resultsDiv = document.getElementById('search-results');
	resultsDiv.innerHTML = '';

	if (!query) {
	  resultsDiv.style.display = 'none';
	  return;
	}

	// Filter boxes whose boxNumber contains the query string
	let matches = boxConfigs.filter(function(cfg) {
	  return String(cfg.boxNumber).indexOf(query) !== -1;
	});

	// Prioritize exact matches, then startsWith, then contains
	matches.sort(function(a, b) {
	  let aStr = String(a.boxNumber);
	  let bStr = String(b.boxNumber);
	  let aExact = aStr === query;
	  let bExact = bStr === query;
	  if (aExact !== bExact) return aExact ? -1 : 1;
	  let aStarts = aStr.indexOf(query) === 0;
	  let bStarts = bStr.indexOf(query) === 0;
	  if (aStarts !== bStarts) return aStarts ? -1 : 1;
	  return a.boxNumber - b.boxNumber;
	});

	// Limit to 20 results
	matches = matches.slice(0, 20);

	if (matches.length === 0) {
	  resultsDiv.innerHTML = '<div id="search-no-results">No results</div>';
	  resultsDiv.style.display = 'block';
	  return;
	}

	matches.forEach(function(cfg) {
	  let item = document.createElement('div');
	  item.className = 'search-result-item';
	  item.textContent = 'Box #' + cfg.boxNumber;
	  item.addEventListener('click', function() {
	    selectSearchResult(cfg);
	    resultsDiv.style.display = 'none';
	    document.getElementById('search-input').value = String(cfg.boxNumber);
	  });
	  resultsDiv.appendChild(item);
	});
	resultsDiv.style.display = 'block';
      }

      function selectSearchResult(cfg) {
	// Compute target camera angles to center this box
	// Box is at (wx, wy, wz) on sphere of radius 2000
	// Camera should be opposite the box so the box is centered in view
	let r = 2000;
	animTargetRotX = asin(constrain(-cfg.wy / r, -1, 1));
	animTargetRotX = constrain(animTargetRotX, -89, 89);
	animTargetRotY = atan2(cfg.wx, cfg.wz);

	// Handle angle wrapping: pick shortest path for camRotY
	animStartRotX = camRotX;
	animStartRotY = camRotY;

	// Normalize angles so we take the short way around
	let diffY = animTargetRotY - animStartRotY;
	while (diffY > 180) diffY -= 360;
	while (diffY < -180) diffY += 360;
	animTargetRotY = animStartRotY + diffY;

	animProgress = 0;
	animTargetBox = cfg;
	isAnimating = true;

	// Clear current selection during animation
	selectedBox = null;
	tooltipDiv.style('display', 'none');
      }

      // Easing function: smooth ease-in-out
      function easeInOutCubic(t) {
	return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      window.addEventListener('DOMContentLoaded', function() {
	initSearch();
      });
    </script>
  </head>
  <body>
    <div id="search-container">
      <div id="search-bar">
        <input id="search-input" type="text" placeholder="Search box #..." autocomplete="off" />
        <button id="search-btn">Search</button>
      </div>
      <div id="search-results"></div>
    </div>
  </body>
</html>
